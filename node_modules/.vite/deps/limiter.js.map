{
  "version": 3,
  "sources": ["../../just-performance/src/browser.ts", "../../limiter/src/clock.ts", "../../limiter/src/TokenBucket.ts", "../../limiter/src/RateLimiter.ts"],
  "sourcesContent": ["const universal = typeof globalThis !== \"undefined\" ? globalThis : global;\nconst performance = universal.performance;\n\nexport { performance };\n", "import { performance } from \"just-performance\";\n\n// generate timestamp or delta\n// see http://nodejs.org/api/process.html#process_process_hrtime\nfunction hrtime(previousTimestamp?: [number, number]): [number, number] {\n  const clocktime = performance.now() * 1e-3;\n  let seconds = Math.floor(clocktime);\n  let nanoseconds = Math.floor((clocktime % 1) * 1e9);\n  if (previousTimestamp != undefined) {\n    seconds = seconds - previousTimestamp[0];\n    nanoseconds = nanoseconds - previousTimestamp[1];\n    if (nanoseconds < 0) {\n      seconds--;\n      nanoseconds += 1e9;\n    }\n  }\n  return [seconds, nanoseconds];\n}\n\n// The current timestamp in whole milliseconds\nexport function getMilliseconds(): number {\n  const [seconds, nanoseconds] = hrtime();\n  return seconds * 1e3 + Math.floor(nanoseconds / 1e6);\n}\n\n// Wait for a specified number of milliseconds before fulfilling the returned promise.\nexport function wait(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n", "import { getMilliseconds, wait } from \"./clock\";\n\nexport type Interval = number | \"second\" | \"sec\" | \"minute\" | \"min\" | \"hour\" | \"hr\" | \"day\";\n\nexport type TokenBucketOpts = {\n  bucketSize: number;\n  tokensPerInterval: number;\n  interval: Interval;\n  parentBucket?: TokenBucket;\n};\n\n/**\n * A hierarchical token bucket for rate limiting. See\n * http://en.wikipedia.org/wiki/Token_bucket for more information.\n *\n * @param options\n * @param options.bucketSize Maximum number of tokens to hold in the bucket.\n *  Also known as the burst rate.\n * @param options.tokensPerInterval Number of tokens to drip into the bucket\n *  over the course of one interval.\n * @param options.interval The interval length in milliseconds, or as\n *  one of the following strings: 'second', 'minute', 'hour', day'.\n * @param options.parentBucket Optional. A token bucket that will act as\n *  the parent of this bucket.\n */\nexport class TokenBucket {\n  bucketSize: number;\n  tokensPerInterval: number;\n  interval: number;\n  parentBucket?: TokenBucket;\n  content: number;\n  lastDrip: number;\n\n  constructor({ bucketSize, tokensPerInterval, interval, parentBucket }: TokenBucketOpts) {\n    this.bucketSize = bucketSize;\n    this.tokensPerInterval = tokensPerInterval;\n\n    if (typeof interval === \"string\") {\n      switch (interval) {\n        case \"sec\":\n        case \"second\":\n          this.interval = 1000;\n          break;\n        case \"min\":\n        case \"minute\":\n          this.interval = 1000 * 60;\n          break;\n        case \"hr\":\n        case \"hour\":\n          this.interval = 1000 * 60 * 60;\n          break;\n        case \"day\":\n          this.interval = 1000 * 60 * 60 * 24;\n          break;\n        default:\n          throw new Error(\"Invalid interval \" + interval);\n      }\n    } else {\n      this.interval = interval;\n    }\n\n    this.parentBucket = parentBucket;\n    this.content = 0;\n    this.lastDrip = getMilliseconds();\n  }\n\n  /**\n   * Remove the requested number of tokens. If the bucket (and any parent\n   * buckets) contains enough tokens this will happen immediately. Otherwise,\n   * the removal will happen when enough tokens become available.\n   * @param count The number of tokens to remove.\n   * @returns A promise for the remainingTokens count.\n   */\n  async removeTokens(count: number): Promise<number> {\n    // Is this an infinite size bucket?\n    if (this.bucketSize === 0) {\n      return Number.POSITIVE_INFINITY;\n    }\n\n    // Make sure the bucket can hold the requested number of tokens\n    if (count > this.bucketSize) {\n      throw new Error(`Requested tokens ${count} exceeds bucket size ${this.bucketSize}`);\n    }\n\n    // Drip new tokens into this bucket\n    this.drip();\n\n    const comeBackLater = async () => {\n      // How long do we need to wait to make up the difference in tokens?\n      const waitMs = Math.ceil((count - this.content) * (this.interval / this.tokensPerInterval));\n      await wait(waitMs);\n      return this.removeTokens(count);\n    };\n\n    // If we don't have enough tokens in this bucket, come back later\n    if (count > this.content) return comeBackLater();\n\n    if (this.parentBucket != undefined) {\n      // Remove the requested from the parent bucket first\n      const remainingTokens = await this.parentBucket.removeTokens(count);\n\n      // Check that we still have enough tokens in this bucket\n      if (count > this.content) return comeBackLater();\n\n      // Tokens were removed from the parent bucket, now remove them from\n      // this bucket. Note that we look at the current bucket and parent\n      // bucket's remaining tokens and return the smaller of the two values\n      this.content -= count;\n\n      return Math.min(remainingTokens, this.content);\n    } else {\n      // Remove the requested tokens from this bucket\n      this.content -= count;\n      return this.content;\n    }\n  }\n\n  /**\n   * Attempt to remove the requested number of tokens and return immediately.\n   * If the bucket (and any parent buckets) contains enough tokens this will\n   * return true, otherwise false is returned.\n   * @param {Number} count The number of tokens to remove.\n   * @param {Boolean} True if the tokens were successfully removed, otherwise\n   *  false.\n   */\n  tryRemoveTokens(count: number): boolean {\n    // Is this an infinite size bucket?\n    if (!this.bucketSize) return true;\n\n    // Make sure the bucket can hold the requested number of tokens\n    if (count > this.bucketSize) return false;\n\n    // Drip new tokens into this bucket\n    this.drip();\n\n    // If we don't have enough tokens in this bucket, return false\n    if (count > this.content) return false;\n\n    // Try to remove the requested tokens from the parent bucket\n    if (this.parentBucket && !this.parentBucket.tryRemoveTokens(count)) return false;\n\n    // Remove the requested tokens from this bucket and return\n    this.content -= count;\n    return true;\n  }\n\n  /**\n   * Add any new tokens to the bucket since the last drip.\n   * @returns {Boolean} True if new tokens were added, otherwise false.\n   */\n  drip(): boolean {\n    if (this.tokensPerInterval === 0) {\n      const prevContent = this.content;\n      this.content = this.bucketSize;\n      return this.content > prevContent;\n    }\n\n    const now = getMilliseconds();\n    const deltaMS = Math.max(now - this.lastDrip, 0);\n    this.lastDrip = now;\n\n    const dripAmount = deltaMS * (this.tokensPerInterval / this.interval);\n    const prevContent = this.content;\n    this.content = Math.min(this.content + dripAmount, this.bucketSize);\n    return Math.floor(this.content) > Math.floor(prevContent);\n  }\n}\n", "import { Interval, TokenBucket } from \"./TokenBucket\";\nimport { getMilliseconds, wait } from \"./clock\";\n\nexport type RateLimiterOpts = {\n  tokensPerInterval: number;\n  interval: Interval;\n  fireImmediately?: boolean;\n};\n\n/**\n * A generic rate limiter. Underneath the hood, this uses a token bucket plus\n * an additional check to limit how many tokens we can remove each interval.\n *\n * @param options\n * @param options.tokensPerInterval Maximum number of tokens that can be\n *  removed at any given moment and over the course of one interval.\n * @param options.interval The interval length in milliseconds, or as\n *  one of the following strings: 'second', 'minute', 'hour', day'.\n * @param options.fireImmediately Whether or not the promise will resolve\n *  immediately when rate limiting is in effect (default is false).\n */\nexport class RateLimiter {\n  tokenBucket: TokenBucket;\n  curIntervalStart: number;\n  tokensThisInterval: number;\n  fireImmediately: boolean;\n\n  constructor({ tokensPerInterval, interval, fireImmediately }: RateLimiterOpts) {\n    this.tokenBucket = new TokenBucket({\n      bucketSize: tokensPerInterval,\n      tokensPerInterval,\n      interval,\n    });\n\n    // Fill the token bucket to start\n    this.tokenBucket.content = tokensPerInterval;\n\n    this.curIntervalStart = getMilliseconds();\n    this.tokensThisInterval = 0;\n    this.fireImmediately = fireImmediately ?? false;\n  }\n\n  /**\n   * Remove the requested number of tokens. If the rate limiter contains enough\n   * tokens and we haven't spent too many tokens in this interval already, this\n   * will happen immediately. Otherwise, the removal will happen when enough\n   * tokens become available.\n   * @param count The number of tokens to remove.\n   * @returns A promise for the remainingTokens count.\n   */\n  async removeTokens(count: number): Promise<number> {\n    // Make sure the request isn't for more than we can handle\n    if (count > this.tokenBucket.bucketSize) {\n      throw new Error(\n        `Requested tokens ${count} exceeds maximum tokens per interval ${this.tokenBucket.bucketSize}`\n      );\n    }\n\n    const now = getMilliseconds();\n\n    // Advance the current interval and reset the current interval token count\n    // if needed\n    if (now < this.curIntervalStart || now - this.curIntervalStart >= this.tokenBucket.interval) {\n      this.curIntervalStart = now;\n      this.tokensThisInterval = 0;\n    }\n\n    // If we don't have enough tokens left in this interval, wait until the\n    // next interval\n    if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval) {\n      if (this.fireImmediately) {\n        return -1;\n      } else {\n        const waitMs = Math.ceil(this.curIntervalStart + this.tokenBucket.interval - now);\n        await wait(waitMs);\n        const remainingTokens = await this.tokenBucket.removeTokens(count);\n        this.tokensThisInterval += count;\n        return remainingTokens;\n      }\n    }\n\n    // Remove the requested number of tokens from the token bucket\n    const remainingTokens = await this.tokenBucket.removeTokens(count);\n    this.tokensThisInterval += count;\n    return remainingTokens;\n  }\n\n  /**\n   * Attempt to remove the requested number of tokens and return immediately.\n   * If the bucket (and any parent buckets) contains enough tokens and we\n   * haven't spent too many tokens in this interval already, this will return\n   * true. Otherwise, false is returned.\n   * @param {Number} count The number of tokens to remove.\n   * @param {Boolean} True if the tokens were successfully removed, otherwise\n   *  false.\n   */\n  tryRemoveTokens(count: number): boolean {\n    // Make sure the request isn't for more than we can handle\n    if (count > this.tokenBucket.bucketSize) return false;\n\n    const now = getMilliseconds();\n\n    // Advance the current interval and reset the current interval token count\n    // if needed\n    if (now < this.curIntervalStart || now - this.curIntervalStart >= this.tokenBucket.interval) {\n      this.curIntervalStart = now;\n      this.tokensThisInterval = 0;\n    }\n\n    // If we don't have enough tokens left in this interval, return false\n    if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval) return false;\n\n    // Try to remove the requested number of tokens from the token bucket\n    const removed = this.tokenBucket.tryRemoveTokens(count);\n    if (removed) {\n      this.tokensThisInterval += count;\n    }\n    return removed;\n  }\n\n  /**\n   * Returns the number of tokens remaining in the TokenBucket.\n   * @returns {Number} The number of tokens remaining.\n   */\n  getTokensRemaining(): number {\n    this.tokenBucket.drip();\n    return this.tokenBucket.content;\n  }\n}\n"],
  "mappings": "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",
  "names": ["prevContent", "remainingTokens"]
}
