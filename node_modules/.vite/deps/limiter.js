import "./chunk-5WRI5ZAA.js";

// node_modules/just-performance/dist/esm/browser.js
var universal = typeof globalThis !== "undefined" ? globalThis : global;
var performance = universal.performance;

// node_modules/limiter/dist/esm/clock.js
function hrtime(previousTimestamp) {
  const clocktime = performance.now() * 1e-3;
  let seconds = Math.floor(clocktime);
  let nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp != void 0) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
function getMilliseconds() {
  const [seconds, nanoseconds] = hrtime();
  return seconds * 1e3 + Math.floor(nanoseconds / 1e6);
}
function wait(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// node_modules/limiter/dist/esm/TokenBucket.js
var TokenBucket = class {
  constructor({ bucketSize, tokensPerInterval, interval, parentBucket }) {
    this.bucketSize = bucketSize;
    this.tokensPerInterval = tokensPerInterval;
    if (typeof interval === "string") {
      switch (interval) {
        case "sec":
        case "second":
          this.interval = 1e3;
          break;
        case "min":
        case "minute":
          this.interval = 1e3 * 60;
          break;
        case "hr":
        case "hour":
          this.interval = 1e3 * 60 * 60;
          break;
        case "day":
          this.interval = 1e3 * 60 * 60 * 24;
          break;
        default:
          throw new Error("Invalid interval " + interval);
      }
    } else {
      this.interval = interval;
    }
    this.parentBucket = parentBucket;
    this.content = 0;
    this.lastDrip = getMilliseconds();
  }
  /**
   * Remove the requested number of tokens. If the bucket (and any parent
   * buckets) contains enough tokens this will happen immediately. Otherwise,
   * the removal will happen when enough tokens become available.
   * @param count The number of tokens to remove.
   * @returns A promise for the remainingTokens count.
   */
  async removeTokens(count) {
    if (this.bucketSize === 0) {
      return Number.POSITIVE_INFINITY;
    }
    if (count > this.bucketSize) {
      throw new Error(`Requested tokens ${count} exceeds bucket size ${this.bucketSize}`);
    }
    this.drip();
    const comeBackLater = async () => {
      const waitMs = Math.ceil((count - this.content) * (this.interval / this.tokensPerInterval));
      await wait(waitMs);
      return this.removeTokens(count);
    };
    if (count > this.content)
      return comeBackLater();
    if (this.parentBucket != void 0) {
      const remainingTokens = await this.parentBucket.removeTokens(count);
      if (count > this.content)
        return comeBackLater();
      this.content -= count;
      return Math.min(remainingTokens, this.content);
    } else {
      this.content -= count;
      return this.content;
    }
  }
  /**
   * Attempt to remove the requested number of tokens and return immediately.
   * If the bucket (and any parent buckets) contains enough tokens this will
   * return true, otherwise false is returned.
   * @param {Number} count The number of tokens to remove.
   * @param {Boolean} True if the tokens were successfully removed, otherwise
   *  false.
   */
  tryRemoveTokens(count) {
    if (!this.bucketSize)
      return true;
    if (count > this.bucketSize)
      return false;
    this.drip();
    if (count > this.content)
      return false;
    if (this.parentBucket && !this.parentBucket.tryRemoveTokens(count))
      return false;
    this.content -= count;
    return true;
  }
  /**
   * Add any new tokens to the bucket since the last drip.
   * @returns {Boolean} True if new tokens were added, otherwise false.
   */
  drip() {
    if (this.tokensPerInterval === 0) {
      const prevContent2 = this.content;
      this.content = this.bucketSize;
      return this.content > prevContent2;
    }
    const now = getMilliseconds();
    const deltaMS = Math.max(now - this.lastDrip, 0);
    this.lastDrip = now;
    const dripAmount = deltaMS * (this.tokensPerInterval / this.interval);
    const prevContent = this.content;
    this.content = Math.min(this.content + dripAmount, this.bucketSize);
    return Math.floor(this.content) > Math.floor(prevContent);
  }
};

// node_modules/limiter/dist/esm/RateLimiter.js
var RateLimiter = class {
  constructor({ tokensPerInterval, interval, fireImmediately }) {
    this.tokenBucket = new TokenBucket({
      bucketSize: tokensPerInterval,
      tokensPerInterval,
      interval
    });
    this.tokenBucket.content = tokensPerInterval;
    this.curIntervalStart = getMilliseconds();
    this.tokensThisInterval = 0;
    this.fireImmediately = fireImmediately !== null && fireImmediately !== void 0 ? fireImmediately : false;
  }
  /**
   * Remove the requested number of tokens. If the rate limiter contains enough
   * tokens and we haven't spent too many tokens in this interval already, this
   * will happen immediately. Otherwise, the removal will happen when enough
   * tokens become available.
   * @param count The number of tokens to remove.
   * @returns A promise for the remainingTokens count.
   */
  async removeTokens(count) {
    if (count > this.tokenBucket.bucketSize) {
      throw new Error(`Requested tokens ${count} exceeds maximum tokens per interval ${this.tokenBucket.bucketSize}`);
    }
    const now = getMilliseconds();
    if (now < this.curIntervalStart || now - this.curIntervalStart >= this.tokenBucket.interval) {
      this.curIntervalStart = now;
      this.tokensThisInterval = 0;
    }
    if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval) {
      if (this.fireImmediately) {
        return -1;
      } else {
        const waitMs = Math.ceil(this.curIntervalStart + this.tokenBucket.interval - now);
        await wait(waitMs);
        const remainingTokens2 = await this.tokenBucket.removeTokens(count);
        this.tokensThisInterval += count;
        return remainingTokens2;
      }
    }
    const remainingTokens = await this.tokenBucket.removeTokens(count);
    this.tokensThisInterval += count;
    return remainingTokens;
  }
  /**
   * Attempt to remove the requested number of tokens and return immediately.
   * If the bucket (and any parent buckets) contains enough tokens and we
   * haven't spent too many tokens in this interval already, this will return
   * true. Otherwise, false is returned.
   * @param {Number} count The number of tokens to remove.
   * @param {Boolean} True if the tokens were successfully removed, otherwise
   *  false.
   */
  tryRemoveTokens(count) {
    if (count > this.tokenBucket.bucketSize)
      return false;
    const now = getMilliseconds();
    if (now < this.curIntervalStart || now - this.curIntervalStart >= this.tokenBucket.interval) {
      this.curIntervalStart = now;
      this.tokensThisInterval = 0;
    }
    if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval)
      return false;
    const removed = this.tokenBucket.tryRemoveTokens(count);
    if (removed) {
      this.tokensThisInterval += count;
    }
    return removed;
  }
  /**
   * Returns the number of tokens remaining in the TokenBucket.
   * @returns {Number} The number of tokens remaining.
   */
  getTokensRemaining() {
    this.tokenBucket.drip();
    return this.tokenBucket.content;
  }
};
export {
  RateLimiter,
  TokenBucket
};
//# sourceMappingURL=limiter.js.map
